diff --git a/simms/src/E-Meerkat.enu.txt b/simms/src/E-Meerkat.enu.txt
deleted file mode 100644
index 641067f..0000000
--- a/simms/src/E-Meerkat.enu.txt
+++ /dev/null
@@ -1,65 +0,0 @@
-#X Y Z dish_diam station mount
--8.700000 24.500000 435.951266 13.500000 00 ALT-AZ
-1.100000 56.500000 388.740097 13.500000 01 ALT-AZ
--33.600000 9.200000 189.746056 13.500000 02 ALT-AZ
--69.500000 29.000000 -300.504966 13.500000 03 ALT-AZ
--129.100000 -16.700000 -320.896612 13.500000 04 ALT-AZ
--106.600000 -43.900000 -183.809848 13.500000 05 ALT-AZ
--19.100000 -55.000000 176.293541 13.500000 06 ALT-AZ
--93.600000 -151.800000 108.732256 13.500000 07 ALT-AZ
--97.700000 -271.100000 404.786574 13.500000 08 ALT-AZ
-33.700000 -123.200000 73.874288 13.500000 09 ALT-AZ
-91.900000 -250.200000 59.423853 13.500000 10 ALT-AZ
-87.600000 -106.100000 -164.161400 13.500000 11 ALT-AZ
-146.100000 -120.700000 224.194936 13.500000 12 ALT-AZ
-247.100000 -143.400000 115.003731 13.500000 13 ALT-AZ
-292.900000 -46.300000 36.300838 13.500000 14 ALT-AZ
-219.800000 13.800000 357.530842 13.500000 15 ALT-AZ
-300.700000 43.800000 86.903781 13.500000 16 ALT-AZ
-208.300000 110.200000 293.167303 13.500000 17 ALT-AZ
-110.300000 -10.300000 290.099647 13.500000 18 ALT-AZ
-178.200000 -45.800000 -146.357514 13.500000 19 ALT-AZ
-101.200000 -58.800000 473.883403 13.500000 20 ALT-AZ
--309.000000 -83.700000 459.748277 13.500000 21 ALT-AZ
--336.500000 83.200000 -360.906814 13.500000 22 ALT-AZ
--389.400000 211.900000 196.169767 13.500000 23 ALT-AZ
--366.500000 346.800000 277.221335 13.500000 24 ALT-AZ
--190.000000 414.900000 -465.073561 13.500000 25 ALT-AZ
--103.400000 226.800000 -157.928432 13.500000 26 ALT-AZ
-42.200000 190.600000 -235.850674 13.500000 27 ALT-AZ
--53.500000 132.800000 122.203164 13.500000 28 ALT-AZ
--92.700000 99.500000 -148.330710 13.500000 29 ALT-AZ
-178.700000 314.200000 362.352097 13.500000 30 ALT-AZ
-257.300000 296.000000 -6.877499 13.500000 31 ALT-AZ
-481.400000 369.700000 470.712773 13.500000 32 ALT-AZ
-606.000000 990.600000 -91.542136 13.500000 33 ALT-AZ
-373.400000 185.900000 -238.275851 13.500000 34 ALT-AZ
-403.000000 48.300000 -247.654650 13.500000 35 ALT-AZ
-405.200000 -50.800000 -267.479554 13.500000 36 ALT-AZ
-396.900000 -202.800000 203.984200 13.500000 37 ALT-AZ
-222.600000 -301.800000 18.385371 13.500000 38 ALT-AZ
-264.800000 -322.600000 -433.618600 13.500000 39 ALT-AZ
--28.100000 -430.900000 346.463948 13.500000 40 ALT-AZ
--300.200000 -385.300000 276.493491 13.500000 41 ALT-AZ
--377.600000 -203.700000 -414.685800 13.500000 42 ALT-AZ
--657.500000 95.700000 362.779432 13.500000 43 ALT-AZ
--935.400000 753.000000 -220.852257 13.500000 44 ALT-AZ
--1913.100000 452.100000 -342.309881 13.500000 45 ALT-AZ
--1531.400000 1791.500000 -26.274429 13.500000 46 ALT-AZ
--603.700000 -255.100000 -85.163903 13.500000 47 ALT-AZ
--2927.800000 2634.900000 36.900321 13.500000 48 ALT-AZ
--3763.700000 605.600000 -166.764810 13.500000 49 ALT-AZ
--2142.400000 -549.300000 66.351726 13.500000 50 ALT-AZ
--887.600000 -482.400000 375.748508 13.500000 51 ALT-AZ
--619.300000 -824.500000 -73.535121 13.500000 52 ALT-AZ
-9.700000 -965.000000 -207.967225 13.500000 53 ALT-AZ
-910.100000 -239.300000 375.332876 13.500000 54 ALT-AZ
-1254.300000 298.600000 -327.354585 13.500000 55 ALT-AZ
-1668.200000 632.400000 -144.292081 13.500000 56 ALT-AZ
-307.400000 3151.400000 -422.092862 13.500000 57 ALT-AZ
-2927.800000 2634.900000 -368.095187 13.500000 58 ALT-AZ
-3847.400000 896.500000 83.132565 13.500000 59 ALT-AZ
-3569.900000 -1447.900000 115.693376 13.500000 60 ALT-AZ
--17.200000 -1884.300000 -437.115977 13.500000 61 ALT-AZ
--1504.100000 -2046.500000 -46.767553 13.500000 62 ALT-AZ
--3569.900000 -1447.900000 160.665283 13.500000 63 ALT-AZ
diff --git a/simms/src/MeerKAT.enu.txt b/simms/src/MeerKAT.enu.txt
deleted file mode 100644
index 6a239ae..0000000
--- a/simms/src/MeerKAT.enu.txt
+++ /dev/null
@@ -1,64 +0,0 @@
--8.7   24.5       0.0
-1.1   56.5        0.0
--33.6   9.2       0.0
--69.5   29.0      0.0
--129.1   -16.7    0.0
--106.6   -43.9    0.0
--19.1   -55.0     0.0
--93.6   -151.8    0.0
--97.7   -271.1    0.0
-33.7   -123.2     0.0
-91.9   -250.2     0.0
-87.6   -106.1     0.0
-146.1   -120.7    0.0
-247.1   -143.4    0.0
-292.9   -46.3     0.0
-219.8   13.8      0.0
-300.7   43.8      0.0
-208.3   110.2     0.0
-110.3   -10.3     0.0
-178.2   -45.8     0.0
-101.2   -58.8     0.0
--309.0   -83.7    0.0
--336.5   83.2     0.0
--389.4   211.9    0.0
--366.5   346.8    0.0
--190.0   414.9    0.0
--103.4   226.8    0.0
-42.2   190.6      0.0
--53.5   132.8     0.0
--92.7   99.5      0.0
-178.7   314.2     0.0
-257.3   296.0     0.0
-481.4   369.7     0.0
-606.0   990.6     0.0
-373.4   185.9     0.0
-403.0   48.3      0.0
-405.2   -50.8     0.0
-396.9   -202.8    0.0
-222.6   -301.8    0.0
-264.8   -322.6    0.0
--28.1   -430.9    0.0
--300.2   -385.3   0.0
--377.6   -203.7   0.0
--657.5   95.7     0.0
--935.4   753.0    0.0
--1913.1   452.1   0.0
--1531.4   1791.5  0.0
--603.7   -255.1   0.0
--2927.8   2634.9  0.0
--3763.7   605.6   0.0
--2142.4   -549.3  0.0
--887.6   -482.4   0.0
--619.3   -824.5   0.0
-9.7   -965.0      0.0
-910.1   -239.3    0.0
-1254.3   298.6    0.0
-1668.2   632.4    0.0
-307.4   3151.4    0.0
-2927.8   2634.9   0.0
-3847.4   896.5    0.0
-3569.9   -1447.9  0.0
--17.2   -1884.3   0.0
--1504.1   -2046.5 0.0
--3569.9   -1447.9 0.0
diff --git a/simms/src/README.md b/simms/src/README.md
deleted file mode 100644
index 5a75dcc..0000000
--- a/simms/src/README.md
+++ /dev/null
@@ -1,38 +0,0 @@
-## uvgen.py
-Makes uv-coverage given a list of antenna positions.  
-The antenna positions may be given in either ENU or ITRF coordinates.  
-This code is Based on:  
-Synthesis Imaging in Radio Astronomy II, ASP conference series, Vol. 180, 1999, Ch. 2
-
-Requires
-----
-* numpy  
-* pylab (matplotlib)  
-* pyrap  
-* python-pyephem 
-
-
-On the command line
------
-First run `./uvgen.py --help` for help  
-
-To test run:
-```
-./uvgen.py -T meerkat -cs enu -dir J2000,56deg,-30deg -st 4 -dt 120 -o uvgen-test.txt -sf uvcov-test.png -S MeerKAT.enu.txt
-``` 
-
-
-In Python
-----
-```
-import uvgen
-
-# initialise UVCreate instance
-uv = uvgen.UVCreate(antennas='MeerKAT.enu.txt', direction="J2000,0,-30", tel="meerkat", coord_sys="enu")
-# In this case I use the lon,lat in the CASA database because tel="meerkat" is known to CASA.
-# If using ENU coordinates, you have to specify coord_sys else ITRF will. 
-
-# To generate the uv-coverage for an 8hr synthesis with a 60s integration time run. 
-uvw = uv.itrf2uvw(h0=[-4,4], dtime=60/3600., save='uvcov-test.png', show=True)
-```
-
diff --git a/simms/src/uvgen.py b/simms/src/uvgen.py
deleted file mode 100755
index 53f84c3..0000000
--- a/simms/src/uvgen.py
+++ /dev/null
@@ -1,340 +0,0 @@
-#!/usr/bin/env python
-## Makes uv-coverage given a list of antenna positions. 
-## The antenna positions may be given in either ENU or ITRF coordinates.
-## This code is Based on: 
-## Synthesis Imaging in Radio Astronomy II, ASP conference series, Vol. 180, 1999, Ch. 2
-## Sphesihle Makhathini sphemakh@gmail.com
-
-## Requires 
-# numpy
-# pylab (matplotlib)
-# pyrap
-# python-pyephem
-
-import sys
-import os
-import time
-import numpy 
-import pylab
-import math
-import pyrap.measures
-import pyrap.quanta as dq
-import ephem 
-import argparse
-
-PI = math.pi
-FWHM = math.sqrt( math.log(256) )
-
-OBSDATA = "uvw points generated using uvgen.py \n"
-
-# Communication functions
-def info(string):
-    t = "%d/%d/%d %d:%d:%d"%(time.localtime()[:6])
-    print "%s ##INFO: %s"%(t, string)
-
-def warn(string):
-    t = "%d/%d/%d %d:%d:%d"%(time.localtime()[:6])
-    print "%s ##WARNING: %s"%(t, string)
-
-def abort(string,exception=None):
-    t = "%d/%d/%d %d:%d:%d"%(time.localtime()[:6])
-    exception = exception or SystemExit 
-    raise exception("%s ##ABORTING: %s"%(t, string))
-
-
-class UVCreate(object):
-
-    def __init__(self, antennas, direction, lon=None, lat=None, tel=None, coord_sys='enu'):
-        """
-            ** Units must be assumed SI, unless stated otherwise. **
-
-            antennas: ASCII file containing (X,Y,Z) or (E,N,U) positions.
-
-            Can also be a list of positions. 
-
-            lat: Lattitude of array
-
-            lon: Longitude of array
-
-            direction: Pointing direction ( specify as "epoch,RA,DEC", e.g 
-            direction="J2000,0deg,-30deg)
-
-            coord_sys: Coordinate system of 'antennas'.
-            Choices are [itrf,enu], default is itrf.
-            
-        """
-
-        dm  = pyrap.measures.measures()
-        
-        self.antennas = antennas
-        self.coord_sys = coord_sys 
-
-        if isinstance(direction,str):
-            direction = direction.split(',')
-        self.direction = direction 
-
-        if tel:
-            lon, lat = [ dm.observatory(tel)[x]['value'] for x in 'm0','m1' ]
-
-        if None in [lon,lat]:
-            abort('"lon" and "lat" or "tel" have to specified')
-
-        self.lat = lat 
-        self.lon = lon 
-
-    
-    def enu2itrf(self, antennas=None, lon=None, lat=None):
-        """ Converts a list of ENU positions to ITRF positions. 
-            Requires a reference positions (lon,lat) in radians. 
-           
-            Returns the ITRF reference position and the ITRF list of positions.
-        """
-        
-        dm  = pyrap.measures.measures()
-        
-        antennas = self.antennas if antennas is None else antennas
-        lon = lon or self.lon
-        lat = lat or self.lat
-        
-        # convtert reference position to itrf system
-        refpos_wgs84 = dm.position('wgs84', dq.quantity(lon, 'rad'),
-                       dq.quantity(lat, 'rad'))
-        refpos = dm.measure(refpos_wgs84, 'itrf')
-
-        lon,lat,rad = [ refpos[x]['value'] for x in 'm0 m1 m2'.split() ]
-
-        xyz0 = rad*numpy.array( [math.cos(lat)*math.cos(lon),
-                        math.cos(lat)*math.sin(lon), math.sin(lat)])
-        
-        # 3x3 transformation matrix. Each row is a normal vector, i.e the rows are (dE,dN,dU)
-        xform = numpy.array([
-            [-math.sin(lon), math.cos(lon), 0],
-            [-math.cos(lon)*math.sin(lat), -math.sin(lon)*math.sin(lat), math.cos(lat)],
-            [math.cos(lat)*math.cos(lon), math.cos(lat)*math.sin(lon), math.sin(lat)]
-])
-        antennas = numpy.array(antennas)
-        xyz = xyz0[numpy.newaxis,:] + antennas.dot(xform)
-
-        return xyz0,xyz
-
-
-    def source_info(self,tot,lon=None,lat=None,direction=None,date=None):
-        
-        dm  = pyrap.measures.measures()
-
-        lon = lon or self.lon
-        lat = lat or self.lat
-        
-        # Set up observer        
-        obs = ephem.Observer()
-        obs.lon, obs.lat = lon,lat
-        direction = direction if direction is not None else self.direction
-
-        if isinstance(direction,str):
-            direction = direction.split(',')
-        ra, dec = [ dm.direction(*direction)[x]['value'] for x in 'm0','m1' ]
-        
-        def sunrise_equation(lat,dec):
-            arg = -math.tan(lat) * math.tan(dec)
-            if arg > 1 or arg< -1:
-                if lat*dec < 0:
-                    warn("Pointing center is always below the horizon!")
-                    return 0
-                else:
-                    info("Pointing center is always above horizon")
-                    return 0
-            th_ha = math.acos( arg )
-            return th_ha
-        
-
-        obs.date = date or "%d/%d/%d 0:0:0"%(time.localtime()[:3])
-        lst = obs.sidereal_time() 
-
-        def change (angle):
-            if angle > 2*PI:
-                angle -= 2*PI
-            elif angle < 0:
-                angle += 2*PI
-            return angle
- 
-        altitude_transit = lambda lat, dec: numpy.sign(lat)*(math.cos(lat)*math.sin(dec) + math.sin(lat)*math.cos(dec) )
-                
-        # First lets find the altitude at transit (hour angle = 0 or LST=RA)
-        # If this is negative, then the pointing direction is below the horizon at its peak.
-        #alt_trans = altitude_transit(lat,dec)
-        #if alt_trans < 0 :
-        #    warn(" Altitude at transit is %f deg, i.e."
-        #         " pointing center is always below the horizon!"%(numpy.rad2deg(alt_trans)))
-        #    return 0
-
-        altitude = altitude_transit(lat,dec)
-        H0 = sunrise_equation(lat,dec)
-
-        # Lets find transit (hour angle = 0, or LST=RA)
-        lst,ra = map(change,(lst,ra))
-        diff =  (lst - ra )/(2*PI)
-
-        date = obs.date
-        obs.date = date - diff
-        # LST should now be transit
-        transit = change(obs.sidereal_time())
-        if ra==0:
-            obs.date = date - lst/(2*PI)
-        elif abs((transit-ra)/ra) > .05:
-            obs.date = date + diff
-
-        # This is the time at transit
-        warn(transit*1)
-        ih0 = change((obs.date)/(2*PI)%(2*PI))
-        # Account for the lower hemisphere
-        if lat<0:
-            ih0 -= PI
-            obs.date -= 0.5
-        
-        date = obs.date.datetime().ctime()
-        return ih0, date, H0, altitude
-        
-    
-    def itrf2uvw(self,h0, antennas=None, dtime=0, direction=None, 
-                 lon=None, lat=None, tel=None, coord_sys=None, date=None,
-                  save=None, show=False):
-        """
-            antennas : ITRF antenna positions (3xN)
-
-            direction: Pointing direction ( specify as "epoch,RA,DEC", e.g 
-               direction="J2000,0deg,-30deg)
-
-            h0 : Hour angle range [start,end] 
-
-            tel : Get telescope lon,lat from CASA database
-        """
-
-        dm  = pyrap.measures.measures()
-
-        if tel:
-            lon, lat = [ dm.observatory(tel)[x]['value'] for x in 'm0','m1' ]
-
-        antennas = self.antennas if antennas is None else antennas
-        lat = lat or self.lat
-        lon = lon or self.lon
-        direction = direction or self.direction
-        coord_sys = coord_sys or self.coord_sys
-
-        if isinstance(antennas,str):
-            antennas = numpy.genfromtxt(antennas)[:,:3]
-
-        if coord_sys == 'enu':
-            antennas = self.enu2itrf(antennas, lon, lat)[1]
-
-        dtime = dtime or 10/3600.
-        
-        if None in [lon,lat]:
-            abort('"lon" and "lat" have to specified')
-        
-        if isinstance(direction,str):
-            direction = direction.split(',')
-
-        ra,dec = [ dm.direction(*direction)[x]['value'] for x in 'm0','m1' ]
-
-        
-        ntimes = (h0[1]-h0[0])/dtime
-        ih0, date, H0, altitude = self.source_info(ntimes*dtime, lon, lat, direction,date=date)
-        h0 = ih0 + numpy.linspace(h0[0], h0[1], ntimes)*PI/12. # convert to radians 
-
-        # define matrix that transforms from ITRF (X,Y,Z) to uvw 
-        mm = numpy.array([
-                [numpy.sin(h0), numpy.cos(h0), 0],
-                [-math.sin(dec)*numpy.cos(h0), math.sin(dec)*numpy.sin(h0), math.cos(dec)],
-                [math.cos(dec)*numpy.cos(h0), -math.cos(dec)*numpy.sin(h0), math.sin(dec)]
-])
-
-
-        # Get baselines 
-        nant = len(antennas)
-        bl = []
-        for i in range(nant):
-            for j in range(i+1,nant):
-                bl.append(antennas[i] - antennas[j])
-
-        # Need some numpy array functionality
-        bl = numpy.array(bl)
-
-        # Finaly, the u,v,w coordinates!
-        u = numpy.outer(mm[0,0],bl[:,0]) + numpy.outer(mm[0,1],bl[:,1]) + numpy.outer(mm[0,2],bl[:,2])
-        v = numpy.outer(mm[1,0],bl[:,0]) + numpy.outer(mm[1,1],bl[:,1]) + numpy.outer(mm[1,2],bl[:,2])
-        w = numpy.outer(mm[2,0],bl[:,0]) + numpy.outer(mm[2,1],bl[:,1]) + numpy.outer(mm[2,2],bl[:,2])
-        
-        u, v, w = [ x.flatten() for x in (u, v, w) ]
-        pylab.plot(u/1e3, v/1e3, 'b.', ms=1)
-        pylab.plot(-u/1e3, -v/1e3, 'r.', ms=1)
-        pylab.xlabel(' |uv| [km]')
-        pylab.ylabel(' |uv| [km]')
-
-        if save:
-            if not isinstance(save, str):
-                save = 'uvgen-qazwsx.png'
-            pylab.savefig(save)
-
-        if show:
-            pylab.show()
-        pylab.clf()
-
-        global OBSDATA
-        uvmax = max( (u**2 + v**2)**0.5)
-
-        OBSDATA += """
-The pointing center is at transit at %s, at which point its altitude is %.3f degress. 
-It will be above the horizon for %.3f hours.
-The maximum baseline for this array is %.3f. km. The u,v,w points are in meters.
-"""%(date,numpy.rad2deg(altitude),2*numpy.rad2deg(H0)/15,uvmax/1e3)
-        info(OBSDATA)        
-        return numpy.array((u, v, w)).T
-
-if __name__ == '__main__':
-
-    for i, arg in enumerate(sys.argv):
-        if (arg[0] == '-') and arg[1].isdigit(): sys.argv[i] = ' ' + arg
-
-    parser = argparse.ArgumentParser(description="Generates the uv-coverage given a list of antenna positions "
-                                     "Sphesihle Makhathini sphemakh@gmail.com")
-    add = parser.add_argument
-
-    add('antennas', 
-        help='File containing antenna positions')
-    add('-cs', '--coord-sys', choices=['enu','itrf'], default='enu',
-        help='Antenna position coordinate system. Default is "enu" ')
-    add('-lon', '--lon', type=float,
-        help='Longitude of array in degrees. No default, '
-             'this is required if --tel is not specified')
-    add('-lat', '--lat', type=float,
-        help='Position of array in degrees. No default, '
-             'this is required if --tel is not specified')
-    add('-T', '--tel', 
-        help='Telescope name. Specify this if your telescope is the CASA database.')
-    add('-dir', '--direction', 
-        help='Pointing direction in the form "reference,ra,dec", e.g "J2000,0deg,-30deg"'
-             'No default. This is required')
-    add('-st', '--synthesis', type=float,
-        help='Synthesis time in hours'
-             'No default. This is required')
-    add('-dt', '--dtime', type=float,
-        help='Integration time in seconds. Default is 10')
-    add('-ST', '--start_time', 
-        help='Synthesis start time in the form "yyyy/mm/dd hh:mm:ss". '
-             'Advanced option: Leave it unspecified if you are not sure its for.')
-    add('-o', '--outfile', default='uvgen-qazwsx.txt',
-        help='Save uv-points here. Default is uvgen-qazwsx.txt')
-    add('-sf', '--savefig',
-        help='Save uv-coverage plot here')
-    add('-S', '--showfig', action='store_true',
-        help='Show uv-coverage plot')
- 
-    opts = parser.parse_args()
-    uv = UVCreate(antennas=opts.antennas, lon=opts.lon, lat=opts.lat, 
-                  direction=opts.direction, tel=opts.tel, coord_sys=opts.coord_sys)
-
-    ha = -opts.synthesis/2,opts.synthesis/2
-    uvw = uv.itrf2uvw(h0=ha, dtime=opts.dtime/3600.,
-            date=opts.start_time, save=opts.savefig, show=opts.showfig)
-    numpy.savetxt(opts.outfile,uvw,header=OBSDATA)
-    info('FIN!')
